<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL索引失效</title>
    <link href="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
    <url>/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p><strong>本篇文章将会详细介绍一下MySQL索引失效有关内容，并且这里会分析某些特殊的场景。</strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>首先介绍一下 MySQL 中的索引，索引是帮助数据库高效获取数据的数据结构，可以理解为数据的目录，MySQL 的 InnoDB 存储引擎的索引数据结构是B+树，这里的详细内容可以查看其他文章，本篇文章主要讲解使用 MySQL 索引失效和一些需要注意的场景。</p><p>首先，我们大致都知道索引失效总共有这些场景：</p><ul><li>查询条件不满足最左前缀原则</li><li>使用模糊匹配，比如like（%在前面的)，这个其实也是最左匹配法则失效的场景</li><li>使用函数或运算符</li><li>遇到范围查询，比如 &gt; 或 &lt; 后面的索引列会失效</li><li>查询条件发生了隐式类型转换</li><li>OR 条件的两个字段中存在非索引字段</li><li>索引选择性差的列</li></ul><h2 id="失效场景"><a href="#失效场景" class="headerlink" title="失效场景"></a>失效场景</h2><h4 id="查询条件不满足最左前缀原则"><a href="#查询条件不满足最左前缀原则" class="headerlink" title="查询条件不满足最左前缀原则"></a>查询条件不满足最左前缀原则</h4><p>对于联合索引，如果查询条件中没有包含索引最左边的列，或者没有连续使用索引列，那么索引可能无法使用。例如，对于联合索引 (A, B, C)，查询条件只包含 B 或者 (B, C)，则可能导致索引失效。</p><p>这里我们怎么理解最左前缀原则呢，我个人的理解是可以看成联合索引局部有序的场景，比如联合索引 (A, B, C)，只有当A有序的时候，B才可以视作有序，B有序的时候，C才可以视作有序。</p><p>这里我们可以类比一下我们常用的字符串比较，比如我们比较 (A，B，C) 和 (A，B，D) ，我们首先比较的是两个字符A，发现这两个它们的 ASCII 值是相等的，接着我们比较下一个字符B和B，发现也是如此，再看下一个字符C和D，这里才发现C的 ASCII 值小于D，因此 (A，B，C) &lt; (A，B，D)，同理，最左前缀原则也是这样。</p><p>这里我们举几个例子</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">假设<span class="hljs-keyword">user</span>表有a，b，c，d四个字段（这里为什么要<span class="hljs-number">4</span>个呢，埋个小彩蛋）<br>并且有联合索引 (a,b,c)<br><br>// 相应的<span class="hljs-keyword">SQL</span>语句如下<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>    a <span class="hljs-type">INT</span>,<br>    b <span class="hljs-type">INT</span>,<br>    c <span class="hljs-type">INT</span>,<br>    d <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_abc <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (a, b, c);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> (a, b, c, d) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Record 1&#x27;</span>),<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Record 2&#x27;</span>),<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Record 3&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Record 4&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Record 5&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Record 6&#x27;</span>);<br></code></pre></td></tr></table></figure><p>先看第一个场景</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> a = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-number">3</span>; // 这里能匹配到(a,b,c),使用<span class="hljs-keyword">EXPLAIN</span>语句可查询到<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%881.png" alt="MySQL索引失效1"></p><p>再看第二个场景</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> a = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-number">3</span>;  // 这里就只能匹配到a，可以看到key_len为5<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%882.png" alt="MySQL索引失效2"></p><p>再看看第三个场景</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-number">3</span>; // 这里就不能匹配到索引<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%883.png" alt="MySQL索引失效3"></p><p>此外，我们还需要注意一种情况</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">// 注意这种情况，虽然顺序不一样，但MySQL的查询优化器会尝试重新排列查询条件以匹配索引的顺序，因此这里还是匹配到了(a,b,c)<br><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> a = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> c = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%884.png" alt="MySQL索引失效4"></p><h4 id="使用模糊匹配，比如like（-在前面的"><a href="#使用模糊匹配，比如like（-在前面的" class="headerlink" title="使用模糊匹配，比如like（%在前面的)"></a>使用模糊匹配，比如like（%在前面的)</h4><p>这个其实也是最左匹配法则失效的场景，因为%在前，就无法匹配最前面的索引值了</p><h4 id="使用函数或运算符"><a href="#使用函数或运算符" class="headerlink" title="使用函数或运算符"></a>使用函数或运算符</h4><p>如果查询条件中使用了函数或运算符，那么查询优化器可能无法对该列使用索引。例如，查询条件为 WHERE UPPER(name) &#x3D; ‘JOHN’ 或 WHERE age + 1 &#x3D; 30 ，此时索引可能失效。</p><h4 id="遇到范围查询，比如-或-后面的索引列会失效"><a href="#遇到范围查询，比如-或-后面的索引列会失效" class="headerlink" title="遇到范围查询，比如 &gt; 或 &lt; 后面的索引列会失效"></a>遇到范围查询，比如 &gt; 或 &lt; 后面的索引列会失效</h4><p>这个也很好理解，也是最左匹配法则失效的场景，假设联合索引 (a,b,c)，使用范围查询a，但是这个时候b就不是有序的了，因为我们联合索引的要求就是，保证a有序的前提下，b才有序。</p><h4 id="查询条件发生了隐式类型转换"><a href="#查询条件发生了隐式类型转换" class="headerlink" title="查询条件发生了隐式类型转换"></a>查询条件发生了隐式类型转换</h4><p>如果查询条件中的数据类型与索引列的数据类型不匹配，数据库可能需要进行隐式类型转换，这可能导致索引失效。例如，对于一个 INT类型的索引列age，如果查询条件为 WHERE age&#x3D; ‘18’ （字符串类型），则可能导致类型转换和索引失效。</p><h4 id="OR-条件的两个字段中存在非索引字段"><a href="#OR-条件的两个字段中存在非索引字段" class="headerlink" title="OR 条件的两个字段中存在非索引字段"></a>OR 条件的两个字段中存在非索引字段</h4><p>如果查询条件中使用了 OR 连接，如果其中一个字段不是索引列，则一定无法使用索引。因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，如果先按照索引列过滤，则无法确定被过滤的列是否满足OR连接的另一个条件。所以对于非索引字段依然需要全表扫描。</p><h4 id="索引选择性差的列"><a href="#索引选择性差的列" class="headerlink" title="索引选择性差的列"></a>索引选择性差的列</h4><p>索引的选择性很差是指某个列上的重复值很多，那么查询优化器可能认为使用全表扫描比使用索引更有效。在这种情况下，索引可能失效。例如，性别列上的索引（只有“男”和“女”两个值）选择性很差，经过查询优化器分析后，索引可能不会被使用。</p><p>这里就要引出我们之前埋下的小彩蛋了，关于优化器相关的索引选择</p><h3 id="违反最左匹配法则的索引选择情况"><a href="#违反最左匹配法则的索引选择情况" class="headerlink" title="违反最左匹配法则的索引选择情况"></a>违反最左匹配法则的索引选择情况</h3><p>有些时候，在使用覆盖索引的情况下，即使不遵循最左前缀的原则也可以使用到索引的情况。主要是因为索引覆盖是对二级索引树进行遍历，既然需要遍历整个二级索引树，自然不会关心是否遵守左前缀。当满足覆盖索引条件时，由于没有回表的代价，查询优化器就可以在不遵循左前缀原则时依然选择遍历二级索引树，而非聚簇索引树。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">假设<span class="hljs-keyword">user</span>表有a，b，c <span class="hljs-number">3</span>个字段<br>并且有联合索引 (a,b)<br><br>// 相应的<span class="hljs-keyword">SQL</span>语句如下<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders (<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    a <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    b <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    c <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">PRIMARY KEY</span> (id)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_ab <span class="hljs-keyword">ON</span> orders (a, b);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (a, b, c) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;521&#x27;</span>,<span class="hljs-string">&#x27;42&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>),<br>(<span class="hljs-string">&#x27;1752&#x27;</span>,<span class="hljs-string">&#x27;24&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>),<br>(<span class="hljs-string">&#x27;15&#x27;</span>,<span class="hljs-string">&#x27;35&#x27;</span>,<span class="hljs-string">&#x27;54&#x27;</span>),<br>(<span class="hljs-string">&#x27;21&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>),<br>(<span class="hljs-string">&#x27;14524&#x27;</span>,<span class="hljs-string">&#x27;272&#x27;</span>,<span class="hljs-string">&#x27;3537&#x27;</span>),<br>(<span class="hljs-string">&#x27;141524&#x27;</span>,<span class="hljs-string">&#x27;2272&#x27;</span>,<span class="hljs-string">&#x27;1537&#x27;</span>);<br></code></pre></td></tr></table></figure><p>我们来看看下面几个SQL语句的执行情况</p><p>首先是这种’2%’，%号在后面的情况</p><p>分别两种情况</p><p>情况1：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> a <span class="hljs-keyword">like</span>  <span class="hljs-string">&#x27;2%&#x27;</span>; // 匹配到索引了，和前面预期相同<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%885.png" alt="MySQL索引失效5"></p><p>情况2：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> id,a,b <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> a <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;2%&#x27;</span>; // 也匹配到索引了，和前面预期相同<br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%888.png" alt="MySQL索引失效8"></p><p>然后我们看’%2’这种，%号在前面的情况：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> a <span class="hljs-keyword">like</span>  <span class="hljs-string">&#x27;%2&#x27;</span>; // 这里发现没用到索引了 <br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%886.png" alt="MySQL索引失效6"></p><p>这时我们再看另一种情况，注意不是SELECT * 了，而是SELECT id,a,b</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> id,a,b <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> a <span class="hljs-keyword">like</span>  <span class="hljs-string">&#x27;%2&#x27;</span>; // 这里竟然用联合上索引了，没有用主键索引 <br></code></pre></td></tr></table></figure><p><img src="/2024/08/01/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%887.png" alt="MySQL索引失效7"></p><p>我们发现这里竟然使用了联合索引，因此可能会产生疑问，这里按照最左前缀原则不是应该联合索引失效了吗，怎么还用上联合索引了</p><p>这里就涉及MySQL优化器的作用了，我们都知道SELECT id,a,b查询是覆盖索引查询，由于这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含主键值字段的值和索引字段的值，所以通过查找二级索引的 B+ 树就能查到全部结果了，因此这里优化器选择了二级索引进行查询。</p><p>需要注意的是，执行计划里的 type 是 index ，说明遍历了整颗二级索引的B+树。而前缀查询的 type 是 range ，表示对索引列进行范围查询，也就是利用了索引树的有序性的特点，通过查询比较的方式，快速定位到了数据行。所以，type&#x3D;range 的查询效率会type&#x3D;index 的高一些。</p><p>这里有个问题需要我们去思考：对于 SELECT id,a,b这种情况，扫描二级索引的B+树和扫描主键索引的B+树都需要扫描整个索引树，为什么不直接扫描主键索引的B+树呢？</p><ol><li><p>二级索引树上的数据相对较少，就只有索引列和主键的值，而主键索引（聚集索引）树上的数据比较多，主键索引树的叶子节点不仅记录了主键值还包含事务 id，以及用于事务和 MVCC的回滚指针以及其他全部列的值；</p></li><li><p>二级索引树上获取数据后不需要回表</p></li></ol><p>所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了全扫描二级索引树的方式查询数据。</p><p>而对于select * 的查询，如果获取了全部字段，也就是包括非索引字段时，这时查询就不能直接从二级索引树上获取到非索引字段的了，需要回表才能获取到。而且每个命中的结果都要进行回表。所以这种情况下查询优化器认为直接扫描主键索引（聚簇索引）树的代价会更低。</p><h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>在使用覆盖索引的情况下，即使不遵循最左匹配的原则也可以使用到索引的情况。主要是因为索引覆盖是对二级索引树进行遍历，既然需要遍历整个二级索引树，自然不会关心是否遵守左前缀。当满足覆盖索引条件时，由于没有回表的代价，查询优化器就可以在不遵循左前缀原则时依然选择遍历二级索引树，而非聚簇索引树。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解二分算法</title>
    <link href="/2024/07/29/%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/29/%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>本篇文章将会详细介绍一下二分查找算法并给出二分查找的具体适用条件和扩展用法。</strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>首先介绍一下二分查找算法</p><p>二分查找算法是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止。</p><p>我们来举个最经典的例子，通过二分查找法找出某个数在有序数组的位置</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 时间复杂度ologn</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 计算中点 m</span><br>        <span class="hljs-keyword">if</span> (nums[m] &lt; <span class="hljs-keyword">target</span>) <span class="hljs-comment">// 此情况说明 target 在区间 [m+1, j] 中</span><br>            i = m + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &gt; <span class="hljs-keyword">target</span>) <span class="hljs-comment">// 此情况说明 target 在区间 [i, m-1] 中</span><br>            j = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 找到目标元素，返回其索引</span><br>            <span class="hljs-keyword">return</span> m;<br>    &#125;<br>    <span class="hljs-comment">// 未找到目标元素，返回 -1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>上面的二分查找相信大部分人都非常熟悉，但是二分算法只能用在有序数组吗？这里我们可以再扩展一下</p><p>二分的本质并不是单调性，即：</p><ul><li>如果有单调性一定可以二分；</li><li>但二分的题目不一定有单调性。</li></ul><p>其实二分的本质是 <strong>边界</strong>，其核心在于找到某种性质可以将区间一分为二。</p><p>比如下图，一个数组可以分为满足条件A和不满足条件A的两个部分，这个时候就出现了边界。</p><p><img src="/2024/07/29/%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE1.png" alt="二分查找1"></p><p>也就是说，只要能区分出这个边界，我们就能够使用二分算法，找到边界上的数。</p><p>这里我们给出二分算法的模板</p><h4 id="模板一"><a href="#模板一" class="headerlink" title="模板一"></a>模板一</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 寻找第一个满足条件A位置的数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>; <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>                r = mid; <span class="hljs-comment">// 如果条件满足，移动右边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 否则移动左边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l; <span class="hljs-comment">// 返回最终的左边界</span><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 寻找最后一个满足条件A位置的数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 选择右中点</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>                l = mid; <span class="hljs-comment">// 如果条件满足，移动左边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 否则移动右边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r; <span class="hljs-comment">// 返回最终的右边界</span><br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>说明：</p><p>为什么第二个模板计算 mid 时需要 + 1？</p><p>当 l &#x3D; r - 1 时，mid &#x3D; (l + r) &#x2F; 2 &#x3D; l，若更新语句为 l &#x3D; mid，则区间未变化，会导致死循环，因此需要 + 1 操作</p></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>光说不练假把式，下面给出一道非常典型的例题供大家练习掌握，相信做完这个例题大家就能发现这两个模板的妙处。</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><p><strong>题目：</strong></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>（看完题目是不是觉得非常契合我们的模板）</p><p><strong>解答：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br><br>        <span class="hljs-comment">// 找到左端点（第一个 &gt;= target 的元素下标）</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= <span class="hljs-keyword">target</span>) &#123;<br>                r = mid; <span class="hljs-comment">// 收缩右边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 移动左边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != <span class="hljs-keyword">target</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        ans[<span class="hljs-number">0</span>] = l; <span class="hljs-comment">// 记录左端点</span><br><br>        <span class="hljs-comment">// 找到右端点（最后一个 &lt;= target 的元素下标）</span><br>        l = <span class="hljs-number">0</span>; <br>        r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 选择右中点</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= <span class="hljs-keyword">target</span>) &#123;<br>                l = mid; <span class="hljs-comment">// 收缩左边界</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 移动右边界</span><br>            &#125;<br>        &#125;<br>        ans[<span class="hljs-number">1</span>] = r; <span class="hljs-comment">// 记录右端点</span><br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序算法</title>
    <link href="/2024/07/24/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/24/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>本篇文章将会详细介绍一下本人所学习的快排算法（会和常规的快排不太一样）。</strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>首先介绍一下快速排序算法</p><p>快速排序是由东尼·霍尔所发展的一种基于分治策略的排序算法。</p><p>快速排序的整体流程如图所示。</p><ol><li>首先，选取一个数字作为哨兵，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</li><li>然后，对左子数组和右子数组分别递归执行“哨兵划分”。</li><li>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。</li></ol><p><img src="/2024/07/24/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort_overview.png" alt="quick_sort_overview"></p><p>哨兵划分就是将一个数组中的元素划分为两块</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，<span class="hljs-number">0</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span><br><span class="hljs-attribute">2</span>左边是小于<span class="hljs-number">2</span>的数字，<span class="hljs-number">2</span>右边是大于等于<span class="hljs-number">2</span>的数字<br></code></pre></td></tr></table></figure><p>我们都知道快排的平均复杂度是O(nlogn)，最差时间复杂度O(n²)，那么什么时候快排时间复杂度是最差呢，我们看下面一种</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">原始数组：<span class="hljs-number">1，2，3，4</span>，<span class="hljs-number">5</span><br>第一次划分后：<span class="hljs-number">1，2，3，4</span>  | <span class="hljs-number">5</span><br>假设每次选取的哨兵都是最右边的数字，那么按照快排算法的迭代，每次都只能划分出来一个元素，这样相当于退化成一个链表每次只取一个元素<br>这种情况的时间复杂度是O(n²)<br></code></pre></td></tr></table></figure><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>如何优化呢，我们发现导致这种情况的出现是哨兵的选取，尽可能不要让它取到数组的边界，因此我们采取的方法是随机选取数组中的元素，尽量选取到一个中间元素，每次划分将数组拆分成长度相同的两半，这样就能尽可能减少上面情况的出现</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">原始数组：<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span><br>选取 <span class="hljs-number">3</span><br>第一次拆分得到：<span class="hljs-number">1</span>，<span class="hljs-number">2</span> | <span class="hljs-type">3</span> | <span class="hljs-type">4</span>，<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>另外，这里还有一个可以优化的地方</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">原始数组：<span class="hljs-number">2，4，1，2</span>，<span class="hljs-number">0，3，2，5</span><br>选取<span class="hljs-number">2</span>作为哨兵<br>第一次划分后得到<span class="hljs-number">1</span>，<span class="hljs-number">0</span>|  <span class="hljs-number">2</span>  |<span class="hljs-number">2，2，4，3</span>，<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>我们发现如果数组中选取的哨兵在数组中有多个重复元素时，按照常规的快排，右边依然要把与哨兵相等的元素再进行划分一次，下一次右边是对2，2，4，3，5进行划分，，相当于每次快排只筛选出了一个元素，既然我们已经知道了2是哨兵，存在重复元素，就可以将右边划分的范围缩小成下面这个样子，相当于每次划分可以筛选出多个元素，中间的就不用再考虑了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，<span class="hljs-number">0</span>|  <span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">2</span>  | <span class="hljs-number">4</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这样每一次划分就可以提升效率，其中具体的做法是在划分中不只确定左边界，还确定右边界</p><p>下面展示代码（java版）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> quickSort1(<span class="hljs-type">int</span>[] arr) &#123;<br>       <span class="hljs-keyword">if</span> (arr == <span class="hljs-keyword">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> process(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>       <span class="hljs-keyword">if</span> (L &gt;= R) &#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       swap(arr, L + (<span class="hljs-type">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);<br>       <span class="hljs-type">int</span>[] equalArea = netherlandsFlag(arr, L, R);<br>       process(arr, L, equalArea[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>);<br>       process(arr, equalArea[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R);<br>   &#125;<br><br>// 划分其实是一个荷兰国旗问题<br>   <span class="hljs-built_in">public</span> static <span class="hljs-type">int</span>[] netherlandsFlag(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>       <span class="hljs-keyword">if</span> (L &gt; R) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (L == R) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;L, R&#125;;<br>       &#125;<br>       <span class="hljs-type">int</span> less = L - <span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> more = R;<br>       <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = L;<br>       // 左右边界一起确定<br>       <span class="hljs-keyword">while</span> (<span class="hljs-keyword">index</span> &lt; more) &#123;<br>           <span class="hljs-keyword">if</span> (arr[<span class="hljs-keyword">index</span>] == arr[R]) &#123;<br>               <span class="hljs-keyword">index</span>++;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[<span class="hljs-keyword">index</span>] &lt; arr[R]) &#123;<br>               swap(arr, <span class="hljs-keyword">index</span>++, ++less);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               swap(arr, <span class="hljs-keyword">index</span>, <span class="hljs-comment">--more);</span><br>           &#125;<br>       &#125;<br>       swap(arr, more, R);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[]&#123;less + <span class="hljs-number">1</span>, more&#125;;<br>   &#125;<br>   <br>   <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>       <span class="hljs-type">int</span> tem = arr[a];<br>       arr[a] = arr[b];<br>       arr[b] = tem;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BIO、NIO、AIO有什么区别？</title>
    <link href="/2024/07/03/BIO%E3%80%81NIO%E3%80%81AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2024/07/03/BIO%E3%80%81NIO%E3%80%81AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>前情回顾，在Netty介绍中，我们介绍了Netty是基于NIO的应用程序框架，那么NIO是什么，和其他IO模式相比，它又有哪些优势呢，这里又会提及几大IO模式，在这里，我们一起介绍</p><p>首先，我们得先知道阻塞IO和非阻塞IO，同步和异步IO的区别。</p><h2 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h2><p>首先我们得清楚，阻塞和非阻塞就是线程访问资源，该资源是否准备就绪的一种处理方式</p><p>阻塞IO：即执行 I&#x2F;O 操作时，如果数据资源没有准备就绪，线程会被阻塞，直到操作完成。在阻塞 I&#x2F;O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I&#x2F;O 模型的性能较差。</p><p><img src="/2024/07/03/BIO%E3%80%81NIO%E3%80%81AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/%E9%98%BB%E5%A1%9EIO.png" alt="阻塞IO"></p><p>非阻塞IO：执行 I&#x2F;O操作时当数据资源尚未准备好时，I&#x2F;O 调用会立即返回。线程可以继续执行其他任务，并通过一些方式比如轮询等方式来反复请求，然后在适当的时候再次尝试执行 I&#x2F;O 操作。非阻塞 I&#x2F;O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。 </p><p><img src="/2024/07/03/BIO%E3%80%81NIO%E3%80%81AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt="非阻塞IO"></p><h2 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h2><p>同步和异步是访问数据的一种机制 ，同步和异步的区别最大在于异步的话调用者不需要等待处理结果， 被调用者会通过回调等机制来通知调用者其返回结果。</p><p>在同步I&#x2F;O中，当进程发起一个I&#x2F;O操作后，它会一直等待直到该操作完成，然后才能继续执行后续的指令。这意味着I&#x2F;O操作的完成</p><p>是程序继续执行的前提。同步 I&#x2F;O 包括阻塞 I&#x2F;O、非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用。</p><p>在异步I&#x2F;O中，当进程发起一个I&#x2F;O操作后，它不会等待该操作完成，而是立即继续执行后续的指令。I&#x2F;O操作完成后，系统会通知进</p><p>程，通常是通过回调函数、信号或事件。</p><p><img src="/2024/07/03/BIO%E3%80%81NIO%E3%80%81AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/%E5%BC%82%E6%AD%A5IO.png" alt="异步IO"></p><h2 id="BIO，NIO，AIO的区别"><a href="#BIO，NIO，AIO的区别" class="headerlink" title="BIO，NIO，AIO的区别"></a>BIO，NIO，AIO的区别</h2><p>知道了什么是阻塞IO和非阻塞IO，什么是同步和异步IO后，我们就可以来详细了解一下这三种IO模式了</p><p>BIO：同步阻塞IO，应用程序发起I&#x2F;O操作后会被阻塞，直到操作完成才返回结果</p><p>NIO：同步非阻塞IO，应用程序发起I&#x2F;O操作后立即返回，不会被阻塞，但需要不断轮询或者使用其他方式来检查I&#x2F;O操作是否完成，仍然需要自己主动完成IO操作。</p><p>AIO：异步非阻塞IO，在执行 I&#x2F;O 操作时，应用程序不需要等待操作的完成。AIO允许应用程序在 I&#x2F;O 操作进行时继续执行其他任务。I&#x2F;O操作完成后，系统会通知应用程序。</p><p>这些IO模式的应用场景：</p><p>BIO适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，但程序直观简单容易理解，jdk1.4之前的唯一选择；</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，并发局限于应用中，编程比较复杂，jdk1.4开始支持；</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS并发操作，编程比较复杂，jdk1.7开始支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这几种常见IO模式的区别，但是你可能还会有疑问，咦？那异步阻塞IO呢，平常都没怎么听过和用过这种IO模式。这个问题其实了解了上文之后联想个例子就清楚了：你想上厕所但坑位满了，但这个时候你其他什么事都不干，就等着有人释放坑位主动来通知你。这是不是一种比较傻乎乎的行为？(๑•́ ₃ •̀๑)ｴｰ</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty线程模型</title>
    <link href="/2024/07/03/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/07/03/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>在Netty介绍那篇我们知道Netty并没有采用传统的IO线程模型，而是采用Reactor事件驱动模型，事件驱动的核心是，以事件为连接点，当有IO事件准备就绪时，以事件的形式通知相关线程进行数据读写，进而业务线程可以直接处理这些数据，这一过程的后续操作方，都是被动接收通知。</p><p>Reactor 模式</p><ul><li>一个或多个请求，同时传递给 服务处理器(基于事件驱动)</li><li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程， 因此Reactor模式也叫Dispatcher模式</li><li>Reactor 模式使用 IO复用 监听事件，收到事件后，分发给某个线程(进程)，这点就是网络服务器高并发处理关键。</li></ul><p>关于Reactor模型，主要常见的有三种模式，我们可以详细了解一下。</p><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>单线程模型：所有IO操作都由同一个NIO线程处理，如图所示</p><p><img src="/2024/07/03/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B1.png" alt="Netty线程模型1"></p><p>我们可以看出这个模型比较简单，没有多线程通信、竞争的问题，全部都在一个线程中完成</p><p>但是这样就会有些问题：</p><ul><li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。在处理某个连接上的业务时，整个服务无法处理其他连接事件，很容易导致性能瓶颈</li><li>程序不可靠，某个服务中的线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，这会导致服务器无响应，是一个很严重的缺陷</li></ul><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>一个单线程监听服务器，一组NIO线程处理IO操作。即一个单线程接收客户端请求，处理客户端连接，然后交给线程池处理，一个线程池由一组NIO线程处理IO操作。</p><p><img src="/2024/07/03/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B2.png" alt="Netty线程模型2"></p><p>这样可以充分的利用多核cpu的处理能力，但是依然有一个缺陷，同一时间无法处理<strong>大量新连接</strong>、<strong>IO就绪事件</strong>。</p><h2 id="主从线程模型"><a href="#主从线程模型" class="headerlink" title="主从线程模型"></a>主从线程模型</h2><p>在多线程模型中，我们提到，其主要缺陷在于同一时间无法处理<strong>大量新连接</strong>、<strong>IO就绪事件</strong>；因此，将主从线程模型应用到这一块，就可以解决这个问题。</p><p>主从线程模型，一组线程池处理连接，接受请求，一组线程池处理IO读写事件</p><ul><li>一来，主 Reactor 可以解决同一时间大量新连接，将其注册到从 Reactor 上进行IO事件监听处理</li><li>二来，IO事件监听相对新连接处理更加耗时，此处我们可以考虑使用线程池来处理。这样能充分利用多核 CPU 的特性，能使更多就绪的IO事件及时处理。</li></ul><p><img src="/2024/07/03/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B3.png" alt="Netty线程模型3"></p><h2 id="Netty具体实现"><a href="#Netty具体实现" class="headerlink" title="Netty具体实现"></a>Netty具体实现</h2><p>Netty的线程模型是基于事件驱动的，它采用了多线程池的架构来处理网络请求和事件。以下是Netty的具体内容：</p><ol><li><strong>Boss线程池（Acceptors）</strong>：这个线程池用于处理新的连接请求，通常会绑定到一个端口，并且负责接受客户端的连接。每个Boss线程都会监听一个独立的套接字，用于接受客户端的连接请求。</li><li><strong>Worker线程池（EventLoopGroup）</strong>：一旦连接建立，客户端的请求会被传递给Worker线程池中的一个EventLoop进行处理。Worker线程池负责处理I&#x2F;O事件，如读取和写入数据，以及执行用户定义的业务逻辑。Netty通常会有多个Worker线程，每个线程都会处理多个连接，通过事件循环（EventLoop）来处理这些连接上的事件。</li><li><strong>EventLoop（事件循环）</strong>：每个Worker线程都包含一个EventLoop，它负责处理一个或多个连接上的事件。EventLoop会持续地从事件队列中获取事件，然后执行相应的操作，比如读取数据、处理请求、写入数据等。每个连接都会被分配到一个特定的EventLoop，确保了事件的顺序性和线程的安全性。</li><li><strong>任务队列</strong>：Netty使用任务队列来存储需要处理的事件，这些事件可以是读写操作、用户自定义的任务或其他事件。这些事件会被EventLoop从队列中取出并执行。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，Netty的线程模型允许多个连接共享同一个线程，避免了线程创建和销毁的开销，提高了系统的性能和效率。通过事件驱动的方式，Netty能够高效地处理大量的并发连接，适用于构建高性能、可扩展的网络应用程序。需要注意的是，具体的线程数目和配置可以根据应用程序的需求进行调整。</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty介绍</title>
    <link href="/2024/07/03/Netty%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/07/03/Netty%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>首先简单一下Netty，什么是Netty？</p><blockquote><p>​Netty提供异步的、事件驱动的⽹络应⽤程序框架和⼯具，⽤以快速开发⾼性能、⾼可靠性的⽹络服务器和客户端程序。也就是说，Netty 是⼀个基于NIO的客户、服务器端的编程框架，使⽤Netty 可以确保你快速和简单的开发出⼀个⽹络应⽤，例如实现了某种协议的客户、服务端应⽤。Netty相当于简化和流线化了⽹络应⽤的编程开发过程，例如：基于TCP和UDP的socket服务开发。</p><p>​“快速”和“简单”并不⽤产⽣维护性或性能上的问题。Netty 是⼀个吸收了多种协议（包括FTP、SMTP、HTTP等各种⼆进制⽂本协议）的实现经验，并经过相当精⼼设计的项⽬。最终，Netty 成功的找到了⼀种⽅式，在保证易于开发的同时还保证了其应⽤的性能，稳定性和伸缩性。</p></blockquote><p>总结一下，Netty是 ⼀个异步事件驱动的⽹络应⽤程序框架，⽤于快速开发可维护的⾼性能协议服务器和客户端。Netty是基于Nio的,封装了jdk的Nio，使⽤起 来更加⽅法灵活。</p><p>Netty可构建⾼性能、低延时的各种Java中间件，例如MQ、分布式服务框架、ESB消息总线等，Netty主要作为基础通信框架提供⾼性能、低⼦延时的通信服务，阿⾥分布式服务框架 Dubbo，默认使⽤ Netty 作为基础通信组 件，还有 RocketMQ 也是使⽤ Netty作为通讯的基础。在我所做的一个聊天服务中，就用Netty搭建聊天服务，经过实测，性能非常好。</p><p>欢迎访问Netty的官网查看具体的内容，<a href="https://netty.io/">Netty</a>。</p><h2 id="Netty有什么特点？"><a href="#Netty有什么特点？" class="headerlink" title="Netty有什么特点？"></a>Netty有什么特点？</h2><p><strong>高并发</strong>：Netty 是⼀款基于 NIO（Nonblocking IO，⾮阻塞IO）开发的⽹络通 信框架，对⽐于 BIO（Blocking I&#x2F;O，阻塞IO），他的并发性能得到了很⼤提⾼。</p><p><strong>传输快</strong>：Netty 的传输依赖于零拷⻉特性，尽量减少不必要的内存拷⻉，实现了 更⾼效率的传输。</p><p><strong>封装好</strong>：Netty 封装了 NIO 操作的很多细节，提供了易于使⽤调⽤接⼝，比如各种handler，还有心跳机制的设置。</p><p>可能抽象的语言描述这几个特点听起来很抽象，所以我单独写了几篇文章介绍Netty中的Nio（包括其他IO机制），零拷贝，欢迎移步查看。</p><h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>Netty作为一个可开发高性能服务的框架，一定有高效的线程模型。</p><p>目前存在的线程模型有：</p><ul><li>传统阻塞 I&#x2F;O 服务模型</li><li>Reactor 模式</li></ul><p>该模型特点</p><ul><li>采用阻塞IO模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ul><p><img src="/2024/07/03/Netty%E4%BB%8B%E7%BB%8D/netty1.png" alt="netty1"></p><p>问题分析</p><ul><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费</li></ul><p>可以看出传统的线程模型会有性能上的瓶颈，而Netty采用的是一种Reactor事件驱动模型。</p><p>这种模型将「连接」和「业务线程」分开处理，当「连接层」有事件触发时提交给「业务线程」，避免了业务线程因「网络数据处于准备中」导致的长时间等待问题，节省线程资源，</p><p>事件驱动的核心是，以事件为连接点，当有IO事件准备就绪时，以事件的形式通知相关线程进行数据读写，进而业务线程可以直接处理这些数据，这一过程的后续操作方，都是被动接收通知，</p><p>而Reactor模型还有三种常见模式，具体我单独写了一篇文章进行介绍</p><h2 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h2><p>关于IO操作，我们知道应用程序是无法直接读取磁盘的，想要访问数据，会涉及系统调用和内核空间缓冲区和用户空间缓冲区数据的拷贝，比较耗时，而Netty有一个零拷贝的机制，尽可能的减少数据拷贝的情况。</p><p>Netty 实现零拷贝主要依赖于以下两个技术：</p><ol><li>零拷贝文件传输：Netty 使用了操作系统提供的零拷贝机制，例如 Linux 下的 sendfile 和 splice 系统调用。这些系统调用可以直接将文件数据从磁盘读取到网络套接字，或者从一个套接字传输到另一个套接字，而无需经过用户空间和内核空间之间的数据拷贝。</li><li>零拷贝内存传输：Netty 使用了 Direct Memory Buffer（直接内存缓冲区）来实现零拷贝内存传输。直接内存缓冲区是一种直接分配在堆外内存的缓冲区，可以通过操作系统的文件描述符直接读写数据，避免了数据在用户空间和内核空间之间的拷贝。</li></ol><p>通过使用这些零拷贝技术，Netty 在进行数据传输时可以避免将数据从一个缓冲区拷贝到另一个缓冲区，从而减少了数据拷贝的次数和数据在内存之间的传输开销。这样可以提高数据传输的效率和性能。</p><p>需要注意的是，零拷贝并不是在所有情况下都能完全避免数据拷贝。在某些情况下，仍然需要进行少量的数据拷贝操作，例如数据的解码和编码过程。但是相比传统的拷贝方式，Netty 的零拷贝机制可以最大程度地减少数据拷贝的次数，提高了性能。</p>]]></content>
    
    
    <categories>
      
      <category>框架篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序算法</title>
    <link href="/2024/06/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/06/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>本篇文章将会详细介绍一下本人所学习的快排算法（包括递归和非递归的实现）。</strong></p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>归并排序（merge sort）是一种基于分治策略的排序算法，包含如图所示的“划分”和“合并”阶段。</p><ol><li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li><li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li></ol><p><img src="/2024/06/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/merge_sort_overview.png" alt="merge_sort_overview"></p><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>由上面的思想可以看出在算法中实现主要就是划分和合并，划分的话就是一个找出中点的过程将原数组划分为（l，mid）和（mid+1，r）的过程，而合并就是合并两个有序数组的常规流程，用一个辅助数组，使用双指针依次遍历两个待合并的数组即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java版代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    process(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l ,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>); <span class="hljs-comment">// 注意这里是防溢出的</span><br>    process(arr,l,m);<br>    process(arr,m+<span class="hljs-number">1</span>,r);<br>    merge(arr,l,m,r);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r-l+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> m+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;=r)&#123;<br>        help[i++] = arr[p1] &lt;= arr[p2]?arr[p1++]:arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= m)&#123;<br>        help[i++] = arr[p1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p2 &lt;=r)&#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt; help.length;i++)&#123;<br>        arr[l+i] = help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于计算归并排序的时间复杂度，其实我们看递归的版本不是很明显，看非递归的版本比较明显。</p><h2 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h2><p>非递归版本也是分为“划分”和“合并”阶段，合并阶段和递归版本是一样的，但是划分阶段就有点区别了。在划分中，我们实际上是从递归终止条件那里开始划分的，我们需要去设置步长（即是每次要合并的范围），最开始就是1，因为最开始只有单个元素是有序的，这样我们就是合并左右两个元素即合并两个大小为1的有序数组，后续逐渐扩大为原来的两倍，即合并两个大小为2的有序数组，依次类推。同时，在合并前，我们需要注意下一次合并的开始下标，并且还要关注一些越界情况和右边有序数组大小可能和左边不一样的情况。</p><p>以下是java版代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mergeSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(mergeSize &lt; n)&#123;<br>        l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; n)&#123;<br>            <span class="hljs-keyword">if</span>(l + mergeSize -<span class="hljs-number">1</span> &gt;= n - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 如果第一个数组最右下标超出原数组大小说明不需要合并了</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + mergeSize -<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Math.min(m+mergeSize,n-<span class="hljs-number">1</span>); <span class="hljs-comment">// 确定要合并的第二个数组的最后一个位置下标，注意不能超出原数组大小</span><br>            merge(arr,l,m,r);  <br>            l = r+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(mergeSize &gt; n /<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        mergeSize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 合并过程和递归版本一样</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r-l+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> m+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= m &amp;&amp; p2 &lt;=r)&#123;<br>        help[i++] = arr[p1] &lt;= arr[p2]?arr[p1++]:arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1 &lt;= m)&#123;<br>        help[i++] = arr[p1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p2 &lt;=r)&#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt; help.length;i++)&#123;<br>        arr[l+i] = help[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归版本要尤其关注合并数组的边界问题，这里我们可以从while循环中看到时间复杂度是O(nlogn)级别的，空间复杂度o(n)级别的</p>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法章节</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
